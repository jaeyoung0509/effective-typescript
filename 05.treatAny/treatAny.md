# 05.
- 타입스크립트의 타입 시스템은 선택적이고 점전적이 때문에 정적이면서도 동적인 특성을 동시에 가짐 
- 타입스크립트는 프로그램 일부에만 타입 시스템을 적용 가능 
- any를 현명하게 사용하는 방법을 배우자
  

## 아이템 38. any 타입은 가능한 좁은 범위에서만 사용하기
- 의도치 않은 타입 안전성의 손실을 줄이기 위해서는 any 사용 범위를 최소로 좁혀야 됨
- - 어쩔수 없이 사용해야 된다면 as 를 통해서 단언적으로 사용하기
- 함수의 반환 타입이 any인 경우 안전성이 나빠짐, 따라서 any 타입으로 반환하지 않기 !
- 강제로 타입 오류를 제거할려면 any대신 @ts-ignore 사용하는 것이 좋음

## 아이템 39. any를 구체적으로 변형해서 사용하기
- any 타입의 값을 그대로 정규식이나 함수에 넣는 것은 권장되지 않음
- 왠만해선 any 쓰지 말자
- any보다 더 정확하게 모델링 할 수 있도록 any[ ]  , 또는 () => any처럼 구체적인 형태를 사용하기
- `unknown`도 있어요
- - any 타입과 동일하게 모든 값을 허용하지만, 할당된 값이 어떤 값인지 모르기때문에 함부로 프로퍼티나 연산을 할 수 없음
  

## 아이템 40. 함수 안으로 타입 단언문 감추기
- 함수를 작성하다 보면 외부로 드러난 타입 정의는 간단하지만 내부 로직이 복잡해서 안전한 타입으로 구현하기 어려운 경우가 많음
- 타입 선언문은 일반적으로 타입을 위험하게 만들지만 상황에 따라 필요하기도 하고 현실적인 해결책, 불가피하게 사용해야 되면 정확한 정의를 가지는 함수 안으로 숨기도록 하자!

## 아이템 41. any의 진화~!
- 타입스크립트에서 일반적으로 변수의 타입은 변수를 선언 할 때 결정
- 그 이후에 정제될 수 있지만(null 체크) 새로운 값이 추가되도록 확장할 수는 없음. 그러나 any 타입과 관련해서 예외인 경우가 존재
``` typescript
function range(start : number , limit :number){
    const out = [];
    for (let i = start ; i < limit ; i++){
        out.push(i);
    }
    return out ; // 반환타입이 any -> number[]로 진화
}
```
- 또는 조건문(분기)에 따라 타입이 진화가 될 수 있음 
- 그럼에도 any를 진화시키는 방식보다 명시적 타입 구문을 사용하는 것이 더 안전한 타입을 유지시킬 수 있음

## 아이템42. 모르는 타입에는 any보다는 unknown 사용하자!
- 어떠한 값이 있지만 그 값의 타입을 모르는 경우에는 unknown 사용
- 사용자가 타입 단언문이나 타입 체크를 사용하도록 강제할려면 unknown을 사용
- {}, object, unknown의 차이점을 이해하기
-  - `{ }` 타입은 null과 undefined를 제외한 모든 값을 포함
- - object 타입은 모든 비기본형 타입으로 이뤄ㅣㅁ 
- - unknown 타입이 도입되기 전에는 {} 가 더 일반적으로 사용되었지만, 최근에는 {} 를 사용하는 경우는 드뭄
- - cf) never 
`unknown`이 모든 타입을 포함하는 슈퍼셋이라면 , 반대로 `never`는 모든 타입의 하위 타입 어떤 다른 값도 `neveer`타입에 할당 할 수 없음 (반환 타입이 없음을 알려주기  딱 좋네 )


## 아이템 43. 몽키 패치보다는 안전한 타입을 사용하기
- 자바스크립트의 장점 중 하나인 객체와 클래스에 임의의 속성을 추가할 수 있을 만큼 유연 **몽키 패치**
- 하지만 객체에 임의의 속성을 추가하는 것은 일반적으로 좋은 설계는 아님
- 예를들어 dom 노드에 데이터를 추가 
- - 그러면 그 데이터는 기본적으로 **전역 변수**가 됨 -> 의존성을 만들게 됨
- - 여기에 타입스크립트 까지 더하면 또 다른 문제가 발생 
- 최신의 해결책은 document ,Dom으로부터 데이터를 분리 
### 분리할 수 없는 경우 
- interface의 특수 기능 중 하나인 보강(augmentation)을 사용하는 것
- - 타입이 더 안전(than any)
- - 속성에 자동완성을 사용 할 수 있음
- - 몽키 패치가 어떤 부분에 적용되었는지 정확한 기록이 남음
- **보강** 에 대해 더 공부하기

## 아이템 44. 타입 커버리지를 추적하여 타입 안정성 유지
- `noImplictAny`가 설정되어 있어도, 명시적 any 또는 서드파티 타입 선언을 통해 any 타입은 코드 내에 여전히 존재할 수 있음
- 작성한 프로그램의 타입이 얼마나 잘 선언되어있는지 추적해야 함